"""
Komas Trading Server - Base Preset
==================================
Abstract base class for all trading presets.
Provides common interface for preset validation, serialization, and generation.

Architecture:
- BasePreset: Abstract class defining preset interface
- PresetConfig: Dataclass for preset configuration
- PresetMetrics: Performance metrics from backtesting

Version: 1.0
Chat: #29 â€” Presets Architecture
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field, asdict
from datetime import datetime
from typing import Dict, List, Optional, Any, Type, ClassVar
from enum import Enum
import json
import hashlib


# ==================== ENUMS ====================

class IndicatorType(str, Enum):
    """Supported indicator types"""
    TRG = "trg"
    DOMINANT = "dominant"


class PresetCategory(str, Enum):
    """Preset categories by trading style"""
    SCALP = "scalp"           # < 15 min trades
    SHORT_TERM = "short-term" # 15 min - 4h
    MID_TERM = "mid-term"     # 4h - 1 day
    SWING = "swing"           # 1-7 days
    LONG_TERM = "long-term"   # > 7 days
    SPECIAL = "special"       # Custom/experimental


class PresetSource(str, Enum):
    """Preset origin source"""
    SYSTEM = "system"         # Auto-generated system presets
    PINE_SCRIPT = "pine_script"  # Imported from TradingView
    OPTIMIZER = "optimizer"   # Generated by optimizer
    MANUAL = "manual"         # User-created
    IMPORTED = "imported"     # Imported from JSON


class FilterProfile(str, Enum):
    """TRG filter profiles for 200 system presets"""
    NONE = "N"       # No filters
    TREND = "T"      # SuperTrend only
    MOMENTUM = "M"   # RSI only  
    STRENGTH = "S"   # ADX only
    FULL = "F"       # All filters


# ==================== DATA CLASSES ====================

@dataclass
class PresetMetrics:
    """
    Performance metrics from backtesting.
    Updated when preset is backtested.
    """
    win_rate: Optional[float] = None
    profit_factor: Optional[float] = None
    total_profit_percent: Optional[float] = None
    max_drawdown_percent: Optional[float] = None
    sharpe_ratio: Optional[float] = None
    total_trades: Optional[int] = None
    avg_trade_percent: Optional[float] = None
    best_month_percent: Optional[float] = None
    worst_month_percent: Optional[float] = None
    
    # Multi-pair metrics
    avg_pairs_profit: Optional[float] = None
    pairs_in_profit_pct: Optional[float] = None
    universality_score: Optional[float] = None  # 0-100
    
    # Last update
    last_backtest_at: Optional[str] = None
    backtest_symbol: Optional[str] = None
    backtest_timeframe: Optional[str] = None
    backtest_period_days: Optional[int] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary, excluding None values"""
        return {k: v for k, v in asdict(self).items() if v is not None}
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PresetMetrics":
        """Create from dictionary"""
        # Filter only known fields
        known_fields = {f.name for f in cls.__dataclass_fields__.values()}
        filtered = {k: v for k, v in data.items() if k in known_fields}
        return cls(**filtered)


@dataclass
class PresetConfig:
    """
    Complete preset configuration.
    Contains all data needed to recreate a preset.
    """
    # Identification
    id: str
    name: str
    indicator_type: str
    
    # Classification
    category: str = "mid-term"
    source: str = "manual"
    
    # Scope (None = universal)
    symbol: Optional[str] = None
    timeframe: Optional[str] = None
    
    # Indicator parameters (polymorphic)
    params: Dict[str, Any] = field(default_factory=dict)
    
    # Metadata
    description: Optional[str] = None
    tags: List[str] = field(default_factory=list)
    is_active: bool = True
    is_favorite: bool = False
    
    # Performance
    metrics: PresetMetrics = field(default_factory=PresetMetrics)
    
    # Timestamps
    created_at: str = field(default_factory=lambda: datetime.utcnow().isoformat())
    updated_at: str = field(default_factory=lambda: datetime.utcnow().isoformat())
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for storage/API"""
        result = asdict(self)
        result['metrics'] = self.metrics.to_dict() if self.metrics else {}
        return result
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PresetConfig":
        """Create from dictionary"""
        # Handle metrics separately
        metrics_data = data.pop('metrics', {})
        metrics = PresetMetrics.from_dict(metrics_data) if metrics_data else PresetMetrics()
        
        # Handle tags
        tags = data.get('tags', [])
        if isinstance(tags, str):
            tags = tags.split(',') if tags else []
        data['tags'] = tags
        
        return cls(metrics=metrics, **data)
    
    def to_json(self) -> str:
        """Serialize to JSON string"""
        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)
    
    @classmethod
    def from_json(cls, json_str: str) -> "PresetConfig":
        """Create from JSON string"""
        return cls.from_dict(json.loads(json_str))


# ==================== BASE PRESET CLASS ====================

class BasePreset(ABC):
    """
    Abstract base class for all presets.
    
    Each indicator type (TRG, Dominant, etc.) has its own preset subclass
    that implements validation and default generation logic.
    
    Usage:
        # Create preset from config
        preset = TRGPreset(config)
        
        # Validate parameters
        is_valid, errors = preset.validate()
        
        # Get indicator params
        params = preset.get_indicator_params()
        
        # Export to dict/JSON
        data = preset.to_dict()
    """
    
    # Class-level indicator type (override in subclass)
    INDICATOR_TYPE: ClassVar[str] = "unknown"
    
    # Default category based on indicator characteristics
    DEFAULT_CATEGORY: ClassVar[str] = "mid-term"
    
    def __init__(self, config: PresetConfig):
        """
        Initialize preset with configuration.
        
        Args:
            config: PresetConfig with all preset data
        """
        self._config = config
        self._validation_errors: List[str] = []
    
    # ==================== ABSTRACT METHODS ====================
    
    @abstractmethod
    def get_default_params(self) -> Dict[str, Any]:
        """
        Return default parameters for this preset type.
        
        Returns:
            Dictionary of default parameter values
        """
        pass
    
    @abstractmethod
    def validate_params(self, params: Dict[str, Any]) -> List[str]:
        """
        Validate indicator parameters.
        
        Args:
            params: Parameter dictionary to validate
            
        Returns:
            List of validation error messages (empty if valid)
        """
        pass
    
    @abstractmethod
    def get_param_schema(self) -> Dict[str, Dict[str, Any]]:
        """
        Return parameter schema for UI generation.
        
        Returns:
            Dictionary with parameter definitions:
            {
                "param_name": {
                    "type": "int|float|bool|select",
                    "label": "Display Name",
                    "default": value,
                    "min": min_value,
                    "max": max_value,
                    "step": step_value,
                    "options": [...],  # for select type
                    "group": "main|tp|sl|filters"
                }
            }
        """
        pass
    
    @abstractmethod
    def calculate_category(self, params: Dict[str, Any]) -> str:
        """
        Calculate appropriate category based on parameters.
        Used for auto-categorization of generated presets.
        
        Args:
            params: Preset parameters
            
        Returns:
            Category string from PresetCategory
        """
        pass
    
    @abstractmethod
    def generate_name(self, params: Dict[str, Any]) -> str:
        """
        Generate preset name from parameters.
        Used for auto-naming of generated presets.
        
        Args:
            params: Preset parameters
            
        Returns:
            Generated name string
        """
        pass
    
    # ==================== PUBLIC METHODS ====================
    
    @property
    def config(self) -> PresetConfig:
        """Get preset configuration"""
        return self._config
    
    @property
    def id(self) -> str:
        """Get preset ID"""
        return self._config.id
    
    @property
    def name(self) -> str:
        """Get preset name"""
        return self._config.name
    
    @property
    def params(self) -> Dict[str, Any]:
        """Get indicator parameters"""
        return self._config.params
    
    @property
    def metrics(self) -> PresetMetrics:
        """Get performance metrics"""
        return self._config.metrics
    
    def validate(self) -> tuple[bool, List[str]]:
        """
        Validate entire preset configuration.
        
        Returns:
            Tuple of (is_valid, error_messages)
        """
        errors = []
        
        # Validate ID
        if not self._config.id:
            errors.append("Preset ID is required")
        
        # Validate name
        if not self._config.name or len(self._config.name.strip()) == 0:
            errors.append("Preset name is required")
        elif len(self._config.name) > 100:
            errors.append("Preset name must be <= 100 characters")
        
        # Validate indicator type
        if self._config.indicator_type != self.INDICATOR_TYPE:
            errors.append(f"Invalid indicator type: expected {self.INDICATOR_TYPE}, got {self._config.indicator_type}")
        
        # Validate category
        try:
            PresetCategory(self._config.category)
        except ValueError:
            errors.append(f"Invalid category: {self._config.category}")
        
        # Validate source
        try:
            PresetSource(self._config.source)
        except ValueError:
            errors.append(f"Invalid source: {self._config.source}")
        
        # Validate params
        param_errors = self.validate_params(self._config.params)
        errors.extend(param_errors)
        
        self._validation_errors = errors
        return len(errors) == 0, errors
    
    def get_validation_errors(self) -> List[str]:
        """Get last validation errors"""
        return self._validation_errors
    
    def get_indicator_params(self) -> Dict[str, Any]:
        """
        Get parameters ready for indicator calculation.
        Applies defaults for missing values.
        
        Returns:
            Complete parameter dictionary
        """
        defaults = self.get_default_params()
        result = defaults.copy()
        result.update(self._config.params)
        return result
    
    def update_params(self, params: Dict[str, Any]) -> bool:
        """
        Update preset parameters.
        
        Args:
            params: New parameter values (partial update allowed)
            
        Returns:
            True if update was successful
        """
        # Merge with existing
        new_params = self._config.params.copy()
        new_params.update(params)
        
        # Validate
        errors = self.validate_params(new_params)
        if errors:
            self._validation_errors = errors
            return False
        
        # Update
        self._config.params = new_params
        self._config.updated_at = datetime.utcnow().isoformat()
        return True
    
    def update_metrics(self, metrics: PresetMetrics) -> None:
        """Update performance metrics"""
        self._config.metrics = metrics
        self._config.updated_at = datetime.utcnow().isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert preset to dictionary"""
        return self._config.to_dict()
    
    def to_json(self) -> str:
        """Convert preset to JSON string"""
        return self._config.to_json()
    
    def clone(self, new_name: Optional[str] = None, new_id: Optional[str] = None) -> "BasePreset":
        """
        Create a copy of this preset.
        
        Args:
            new_name: Name for the cloned preset (optional)
            new_id: ID for the cloned preset (optional)
            
        Returns:
            New preset instance
        """
        data = self._config.to_dict()
        
        # Generate new ID if not provided
        if new_id:
            data['id'] = new_id
        else:
            data['id'] = self._generate_id(new_name or data['name'])
        
        # Update name if provided
        if new_name:
            data['name'] = new_name
        
        # Reset metrics and timestamps
        data['metrics'] = {}
        data['created_at'] = datetime.utcnow().isoformat()
        data['updated_at'] = data['created_at']
        data['source'] = PresetSource.MANUAL.value
        data['is_favorite'] = False
        
        # Create new config and preset
        new_config = PresetConfig.from_dict(data)
        return self.__class__(new_config)
    
    # ==================== HELPER METHODS ====================
    
    def _generate_id(self, name: str) -> str:
        """Generate unique ID for preset"""
        key = f"{self.INDICATOR_TYPE}:{name}:{datetime.utcnow().isoformat()}"
        hash_part = hashlib.md5(key.encode()).hexdigest()[:8]
        clean_name = name.replace(" ", "_").replace("/", "_")[:20]
        return f"{self.INDICATOR_TYPE.upper()}_{clean_name}_{hash_part}"
    
    @classmethod
    def create_from_params(
        cls,
        params: Dict[str, Any],
        name: Optional[str] = None,
        category: Optional[str] = None,
        source: str = "manual",
        **kwargs
    ) -> "BasePreset":
        """
        Factory method to create preset from parameters.
        
        Args:
            params: Indicator parameters
            name: Optional preset name (auto-generated if None)
            category: Optional category (auto-calculated if None)
            source: Preset source
            **kwargs: Additional PresetConfig fields
            
        Returns:
            New preset instance
        """
        # Create temporary instance for name/category generation
        temp_config = PresetConfig(
            id="temp",
            name="temp",
            indicator_type=cls.INDICATOR_TYPE,
            params=params
        )
        temp_preset = cls(temp_config)
        
        # Generate name if not provided
        if name is None:
            name = temp_preset.generate_name(params)
        
        # Calculate category if not provided
        if category is None:
            category = temp_preset.calculate_category(params)
        
        # Generate ID
        preset_id = temp_preset._generate_id(name)
        
        # Create final config
        config = PresetConfig(
            id=preset_id,
            name=name,
            indicator_type=cls.INDICATOR_TYPE,
            category=category,
            source=source,
            params=params,
            **kwargs
        )
        
        return cls(config)
    
    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(id='{self.id}', name='{self.name}')"
    
    def __eq__(self, other) -> bool:
        if not isinstance(other, BasePreset):
            return False
        return self.id == other.id
    
    def __hash__(self) -> int:
        return hash(self.id)


# ==================== EXPORTS ====================

__all__ = [
    # Enums
    "IndicatorType",
    "PresetCategory", 
    "PresetSource",
    "FilterProfile",
    
    # Data classes
    "PresetMetrics",
    "PresetConfig",
    
    # Base class
    "BasePreset",
]
