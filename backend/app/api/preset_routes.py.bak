"""
Komas Trading Server - Preset API Routes (v2)
==============================================
REST API for managing indicator presets.

Endpoints:
- GET    /api/presets/list              - List all presets
- GET    /api/presets/stats             - Get preset statistics
- GET    /api/presets/{id}              - Get single preset
- POST   /api/presets/create            - Create new preset
- PUT    /api/presets/{id}              - Update preset
- DELETE /api/presets/{id}              - Delete preset
- POST   /api/presets/import            - Import preset from JSON
- GET    /api/presets/export/{id}       - Export preset to JSON

NEW in Chat #31-33:
- POST   /api/presets/clone/{id}        - Clone an existing preset
- POST   /api/presets/backup            - Backup all presets to JSON
- POST   /api/presets/restore           - Restore presets from backup
- POST   /api/presets/batch/delete      - Delete multiple presets
- POST   /api/presets/batch/update      - Update multiple presets
- POST   /api/presets/batch/export      - Export multiple presets

Dominant-specific:
- GET    /api/presets/dominant/list     - List Dominant presets only
- POST   /api/presets/dominant/create   - Create Dominant preset (simplified)
- POST   /api/presets/dominant/seed     - Seed system presets (125+ from GG)

Chat: #31-33 â€” Presets Full Module
"""
import json
import logging
from datetime import datetime
from typing import Optional, List
from io import BytesIO
import zipfile

from fastapi import APIRouter, HTTPException, Query, Body, File, UploadFile
from fastapi.responses import JSONResponse, StreamingResponse

from app.database.presets_db import (
    ensure_presets_table,
    create_preset,
    get_preset,
    get_preset_by_name,
    list_presets,
    count_presets,
    update_preset,
    delete_preset,
    delete_presets_by_source,
    bulk_create_presets,
    get_preset_stats,
    get_all_presets,
    delete_presets_by_ids,
    update_presets_by_ids,
)
from app.models.preset_models import (
    PresetCreate,
    PresetUpdate,
    PresetResponse,
    PresetListResponse,
    PresetStatsResponse,
    DominantPresetCreate,
    DominantPresetResponse
)

router = APIRouter(prefix="/api/presets", tags=["presets"])
logger = logging.getLogger(__name__)


# ============ GENERAL ENDPOINTS ============

@router.get("/list", response_model=PresetListResponse)
async def list_all_presets(
    indicator_type: Optional[str] = Query(None, description="Filter by indicator: trg, dominant"),
    category: Optional[str] = Query(None, description="Filter by category"),
    source: Optional[str] = Query(None, description="Filter by source"),
    symbol: Optional[str] = Query(None, description="Filter by symbol"),
    timeframe: Optional[str] = Query(None, description="Filter by timeframe"),
    is_active: Optional[bool] = Query(None, description="Filter by active status"),
    is_favorite: Optional[bool] = Query(None, description="Filter by favorite"),
    search: Optional[str] = Query(None, description="Search in name/description"),
    limit: int = Query(100, ge=1, le=1000),
    offset: int = Query(0, ge=0)
):
    """List all presets with optional filters"""
    try:
        presets = list_presets(
            indicator_type=indicator_type,
            category=category,
            source=source,
            symbol=symbol,
            timeframe=timeframe,
            is_active=is_active,
            is_favorite=is_favorite,
            search=search,
            limit=limit,
            offset=offset
        )
        
        total = count_presets(
            indicator_type=indicator_type,
            category=category,
            source=source,
            is_active=is_active
        )
        
        return PresetListResponse(
            total=total,
            presets=[_dict_to_response(p) for p in presets]
        )
    except Exception as e:
        logger.error(f"Error listing presets: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/stats", response_model=PresetStatsResponse)
async def get_stats():
    """Get preset statistics"""
    try:
        stats = get_preset_stats()
        return PresetStatsResponse(**stats)
    except Exception as e:
        logger.error(f"Error getting preset stats: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{preset_id}", response_model=PresetResponse)
async def get_single_preset(preset_id: str):
    """Get single preset by ID"""
    preset = get_preset(preset_id)
    if not preset:
        raise HTTPException(status_code=404, detail=f"Preset {preset_id} not found")
    return _dict_to_response(preset)


@router.post("/create", response_model=PresetResponse)
async def create_new_preset(data: PresetCreate):
    """Create a new preset"""
    try:
        preset = create_preset(
            name=data.name,
            indicator_type=data.indicator_type,
            params=data.params,
            category=data.category,
            description=data.description,
            symbol=data.symbol,
            timeframe=data.timeframe,
            source=data.source,
            tags=data.tags
        )
        return _dict_to_response(preset)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Error creating preset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/{preset_id}", response_model=PresetResponse)
async def update_existing_preset(preset_id: str, data: PresetUpdate):
    """Update an existing preset"""
    try:
        # Convert to dict, exclude None values
        update_data = data.model_dump(exclude_none=True)
        
        preset = update_preset(preset_id, **update_data)
        if not preset:
            raise HTTPException(status_code=404, detail=f"Preset {preset_id} not found")
        
        return _dict_to_response(preset)
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error updating preset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/{preset_id}")
async def delete_existing_preset(preset_id: str):
    """Delete a preset"""
    deleted = delete_preset(preset_id)
    if not deleted:
        raise HTTPException(status_code=404, detail=f"Preset {preset_id} not found")
    return {"success": True, "deleted": preset_id}


# ============ NEW: CLONE ENDPOINT ============

@router.post("/clone/{preset_id}")
async def clone_preset(
    preset_id: str,
    new_name: Optional[str] = Query(None, description="Name for cloned preset"),
    include_stats: bool = Query(False, description="Include performance stats")
):
    """Clone an existing preset"""
    try:
        # Get original preset
        original = get_preset(preset_id)
        if not original:
            raise HTTPException(status_code=404, detail=f"Preset {preset_id} not found")
        
        # Generate new name
        clone_name = new_name or f"{original['name']} (Copy)"
        
        # Check if name already exists
        existing = get_preset_by_name(clone_name)
        if existing:
            # Add number suffix
            i = 1
            while get_preset_by_name(f"{clone_name} {i}"):
                i += 1
            clone_name = f"{clone_name} {i}"
        
        # Create clone
        clone_data = {
            "name": clone_name,
            "indicator_type": original.get("indicator_type", "dominant"),
            "params": original.get("params", {}),
            "category": original.get("category", "mid-term"),
            "description": f"Clone of {original['name']}",
            "symbol": original.get("symbol"),
            "timeframe": original.get("timeframe"),
            "source": "manual",  # Cloned presets are always manual
            "tags": original.get("tags", [])
        }
        
        # Optionally include performance stats
        if include_stats:
            for stat_field in ["win_rate", "profit_factor", "total_profit_percent", 
                              "max_drawdown_percent", "sharpe_ratio"]:
                if original.get(stat_field) is not None:
                    clone_data[stat_field] = original[stat_field]
        
        cloned_preset = create_preset(**clone_data)
        
        return {
            "success": True,
            "original_id": preset_id,
            "clone": _dict_to_response(cloned_preset)
        }
    except HTTPException:
        raise
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Error cloning preset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============ NEW: BACKUP/RESTORE ENDPOINTS ============

@router.post("/backup")
async def backup_presets(
    indicator_type: Optional[str] = Query(None, description="Filter by indicator type"),
    source: Optional[str] = Query(None, description="Filter by source"),
    include_system: bool = Query(True, description="Include system presets"),
    format: str = Query("json", description="Format: json or zip")
):
    """Backup presets to JSON or ZIP file"""
    try:
        # Get all presets matching filters
        presets = get_all_presets(
            indicator_type=indicator_type,
            source=source if source else None
        )
        
        # Filter out system presets if requested
        if not include_system:
            presets = [p for p in presets if p.get("source") not in ["system", "pine_script"]]
        
        # Prepare backup data
        backup_data = {
            "version": "1.0",
            "created_at": datetime.utcnow().isoformat(),
            "total_presets": len(presets),
            "filters": {
                "indicator_type": indicator_type,
                "source": source,
                "include_system": include_system
            },
            "presets": []
        }
        
        for p in presets:
            preset_export = {
                "name": p["name"],
                "description": p.get("description"),
                "indicator_type": p.get("indicator_type", "dominant"),
                "category": p.get("category", "mid-term"),
                "symbol": p.get("symbol"),
                "timeframe": p.get("timeframe"),
                "params": p.get("params", {}),
                "source": p.get("source", "manual"),
                "tags": p.get("tags", []),
                "is_favorite": p.get("is_favorite", False),
                # Performance stats
                "win_rate": p.get("win_rate"),
                "profit_factor": p.get("profit_factor"),
                "total_profit_percent": p.get("total_profit_percent"),
                "max_drawdown_percent": p.get("max_drawdown_percent"),
                "sharpe_ratio": p.get("sharpe_ratio"),
            }
            backup_data["presets"].append(preset_export)
        
        if format == "zip":
            # Create ZIP with JSON inside
            buffer = BytesIO()
            with zipfile.ZipFile(buffer, 'w', zipfile.ZIP_DEFLATED) as zf:
                json_content = json.dumps(backup_data, indent=2, ensure_ascii=False)
                zf.writestr("presets_backup.json", json_content)
            
            buffer.seek(0)
            timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
            
            return StreamingResponse(
                buffer,
                media_type="application/zip",
                headers={
                    "Content-Disposition": f'attachment; filename="komas_presets_backup_{timestamp}.zip"'
                }
            )
        else:
            # Return JSON directly
            timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
            return JSONResponse(
                content=backup_data,
                headers={
                    "Content-Disposition": f'attachment; filename="komas_presets_backup_{timestamp}.json"'
                }
            )
            
    except Exception as e:
        logger.error(f"Error creating backup: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/restore")
async def restore_presets(
    file: UploadFile = File(...),
    mode: str = Query("skip", description="Mode: skip, replace, or merge"),
    dry_run: bool = Query(False, description="Validate without importing")
):
    """
    Restore presets from backup file.
    
    Modes:
    - skip: Skip existing presets (by name)
    - replace: Replace existing presets
    - merge: Update existing, create new
    """
    try:
        # Read file content
        content = await file.read()
        
        # Check if ZIP
        if file.filename.endswith('.zip'):
            with zipfile.ZipFile(BytesIO(content)) as zf:
                # Find JSON file in ZIP
                json_files = [f for f in zf.namelist() if f.endswith('.json')]
                if not json_files:
                    raise HTTPException(status_code=400, detail="No JSON file found in ZIP")
                
                with zf.open(json_files[0]) as jf:
                    backup_data = json.loads(jf.read().decode('utf-8'))
        else:
            backup_data = json.loads(content.decode('utf-8'))
        
        # Validate backup structure
        if "presets" not in backup_data:
            raise HTTPException(status_code=400, detail="Invalid backup format: missing 'presets' key")
        
        presets_to_restore = backup_data["presets"]
        
        # Statistics
        stats = {
            "total_in_backup": len(presets_to_restore),
            "created": 0,
            "updated": 0,
            "skipped": 0,
            "errors": 0,
            "error_details": []
        }
        
        if dry_run:
            # Just validate
            for preset in presets_to_restore:
                # Check required fields
                if not preset.get("name"):
                    stats["errors"] += 1
                    stats["error_details"].append(f"Missing name in preset")
                    continue
                if not preset.get("params"):
                    stats["errors"] += 1
                    stats["error_details"].append(f"Missing params in preset: {preset.get('name')}")
                    continue
                
                # Check if exists
                existing = get_preset_by_name(preset["name"])
                if existing:
                    if mode == "skip":
                        stats["skipped"] += 1
                    else:
                        stats["updated"] += 1
                else:
                    stats["created"] += 1
            
            return {
                "success": True,
                "dry_run": True,
                "mode": mode,
                **stats
            }
        
        # Actually restore
        for preset in presets_to_restore:
            try:
                # Validate
                if not preset.get("name") or not preset.get("params"):
                    stats["errors"] += 1
                    continue
                
                existing = get_preset_by_name(preset["name"])
                
                if existing:
                    if mode == "skip":
                        stats["skipped"] += 1
                        continue
                    elif mode in ["replace", "merge"]:
                        # Update existing
                        update_preset(
                            existing["id"],
                            description=preset.get("description"),
                            category=preset.get("category", "mid-term"),
                            params=preset.get("params"),
                            tags=preset.get("tags"),
                            is_favorite=preset.get("is_favorite", False)
                        )
                        stats["updated"] += 1
                else:
                    # Create new
                    create_preset(
                        name=preset["name"],
                        indicator_type=preset.get("indicator_type", "dominant"),
                        params=preset["params"],
                        category=preset.get("category", "mid-term"),
                        description=preset.get("description"),
                        symbol=preset.get("symbol"),
                        timeframe=preset.get("timeframe"),
                        source=preset.get("source", "imported"),
                        tags=preset.get("tags")
                    )
                    stats["created"] += 1
                    
            except Exception as e:
                stats["errors"] += 1
                stats["error_details"].append(f"Error with {preset.get('name', 'unknown')}: {str(e)}")
        
        return {
            "success": True,
            "dry_run": False,
            "mode": mode,
            **stats
        }
        
    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail="Invalid JSON format")
    except Exception as e:
        logger.error(f"Error restoring backup: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============ NEW: BATCH OPERATIONS ============

@router.post("/batch/delete")
async def batch_delete_presets(
    preset_ids: List[str] = Body(..., description="List of preset IDs to delete"),
    confirm: bool = Query(False, description="Confirm deletion")
):
    """Delete multiple presets at once"""
    if not confirm:
        return {
            "success": False,
            "message": "Deletion not confirmed. Add ?confirm=true to proceed.",
            "preset_ids": preset_ids,
            "count": len(preset_ids)
        }
    
    try:
        deleted_count = delete_presets_by_ids(preset_ids)
        
        return {
            "success": True,
            "deleted": deleted_count,
            "requested": len(preset_ids),
            "not_found": len(preset_ids) - deleted_count
        }
    except Exception as e:
        logger.error(f"Error batch deleting presets: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/batch/update")
async def batch_update_presets(
    preset_ids: List[str] = Body(..., embed=True, description="List of preset IDs"),
    updates: dict = Body(..., embed=True, description="Fields to update")
):
    """
    Update multiple presets at once.
    
    Allowed fields: category, is_active, is_favorite, tags
    """
    try:
        # Validate allowed fields
        allowed_fields = {"category", "is_active", "is_favorite", "tags"}
        invalid_fields = set(updates.keys()) - allowed_fields
        
        if invalid_fields:
            raise HTTPException(
                status_code=400, 
                detail=f"Invalid fields for batch update: {invalid_fields}. Allowed: {allowed_fields}"
            )
        
        updated_count = update_presets_by_ids(preset_ids, updates)
        
        return {
            "success": True,
            "updated": updated_count,
            "requested": len(preset_ids),
            "updates_applied": updates
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error batch updating presets: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/batch/export")
async def batch_export_presets(
    preset_ids: List[str] = Body(..., description="List of preset IDs to export")
):
    """Export multiple presets to JSON"""
    try:
        presets = []
        not_found = []
        
        for pid in preset_ids:
            preset = get_preset(pid)
            if preset:
                presets.append({
                    "name": preset["name"],
                    "description": preset.get("description"),
                    "indicator_type": preset.get("indicator_type", "dominant"),
                    "category": preset.get("category", "mid-term"),
                    "symbol": preset.get("symbol"),
                    "timeframe": preset.get("timeframe"),
                    "params": preset.get("params", {}),
                    "tags": preset.get("tags", [])
                })
            else:
                not_found.append(pid)
        
        export_data = {
            "version": "1.0",
            "created_at": datetime.utcnow().isoformat(),
            "total_presets": len(presets),
            "not_found": not_found,
            "presets": presets
        }
        
        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        
        return JSONResponse(
            content=export_data,
            headers={
                "Content-Disposition": f'attachment; filename="komas_presets_export_{timestamp}.json"'
            }
        )
        
    except Exception as e:
        logger.error(f"Error batch exporting presets: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============ IMPORT/EXPORT ENDPOINTS ============

@router.post("/import")
async def import_preset(preset_json: dict = Body(...)):
    """Import preset from JSON"""
    try:
        # Validate required fields
        required = ["name", "indicator_type", "params"]
        for field in required:
            if field not in preset_json:
                raise HTTPException(status_code=400, detail=f"Missing required field: {field}")
        
        preset = create_preset(
            name=preset_json.get("name"),
            indicator_type=preset_json.get("indicator_type"),
            params=preset_json.get("params"),
            category=preset_json.get("category", "mid-term"),
            description=preset_json.get("description"),
            symbol=preset_json.get("symbol"),
            timeframe=preset_json.get("timeframe"),
            source="imported",
            tags=preset_json.get("tags")
        )
        
        return {"success": True, "preset": _dict_to_response(preset)}
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error importing preset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/export/{preset_id}")
async def export_preset(preset_id: str):
    """Export preset to JSON"""
    preset = get_preset(preset_id)
    if not preset:
        raise HTTPException(status_code=404, detail=f"Preset {preset_id} not found")
    
    # Remove internal fields
    export_data = {
        "name": preset["name"],
        "description": preset.get("description"),
        "indicator_type": preset["indicator_type"],
        "category": preset.get("category"),
        "symbol": preset.get("symbol"),
        "timeframe": preset.get("timeframe"),
        "params": preset["params"],
        "tags": preset.get("tags", [])
    }
    
    return JSONResponse(
        content=export_data,
        headers={
            "Content-Disposition": f'attachment; filename="{preset_id}.json"'
        }
    )


# ============ DOMINANT-SPECIFIC ENDPOINTS ============

@router.get("/dominant/list")
async def list_dominant_presets(
    category: Optional[str] = Query(None),
    source: Optional[str] = Query(None),
    symbol: Optional[str] = Query(None),
    timeframe: Optional[str] = Query(None),
    search: Optional[str] = Query(None),
    limit: int = Query(500, ge=1, le=1000),
    offset: int = Query(0, ge=0)
):
    """List Dominant presets only"""
    try:
        presets = list_presets(
            indicator_type="dominant",
            category=category,
            source=source,
            symbol=symbol,
            timeframe=timeframe,
            search=search,
            limit=limit,
            offset=offset
        )
        
        total = count_presets(indicator_type="dominant", category=category, source=source)
        
        # Convert to DominantPresetResponse
        dominant_presets = []
        for p in presets:
            resp = _dict_to_response(p)
            dom_resp = DominantPresetResponse.from_preset_response(resp)
            dominant_presets.append(dom_resp.model_dump())
        
        return {
            "total": total,
            "presets": dominant_presets
        }
    except Exception as e:
        logger.error(f"Error listing Dominant presets: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/dominant/categories")
async def get_dominant_categories():
    """Get available categories with counts"""
    try:
        stats = get_preset_stats()
        return {
            "categories": stats.get("by_category", {}),
            "total": stats.get("total_presets", 0)
        }
    except Exception as e:
        logger.error(f"Error getting categories: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/dominant/create")
async def create_dominant_preset(data: DominantPresetCreate):
    """Create Dominant preset with simplified schema"""
    try:
        generic = data.to_preset_create()
        
        preset = create_preset(
            name=generic.name,
            indicator_type=generic.indicator_type,
            params=generic.params,
            category=generic.category,
            description=generic.description,
            symbol=generic.symbol,
            timeframe=generic.timeframe,
            source=generic.source,
            tags=generic.tags
        )
        
        resp = _dict_to_response(preset)
        return DominantPresetResponse.from_preset_response(resp).model_dump()
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Error creating Dominant preset: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/dominant/seed")
async def seed_dominant_presets(
    force: bool = Query(False, description="Delete existing pine_script presets and re-seed")
):
    """Seed Dominant presets from GG Pine Script (125+ presets)"""
    try:
        from app.migrations.seed_dominant_presets import seed_all_dominant_presets
        
        if force:
            # Delete existing pine_script presets
            deleted = delete_presets_by_source("pine_script")
            logger.info(f"Deleted {deleted} existing pine_script presets")
        
        result = seed_all_dominant_presets()
        
        return {
            "success": True,
            "created": result.get("created", 0),
            "skipped": result.get("skipped", 0),
            "errors": result.get("errors", 0),
            "total_dominant": count_presets(indicator_type="dominant")
        }
    except Exception as e:
        logger.error(f"Error seeding presets: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/dominant/clear")
async def clear_dominant_presets(
    source: str = Query("pine_script", description="Source to clear")
):
    """Clear Dominant presets by source (for re-migration)"""
    try:
        deleted = delete_presets_by_source(source)
        return {
            "success": True,
            "deleted": deleted,
            "remaining": count_presets(indicator_type="dominant")
        }
    except Exception as e:
        logger.error(f"Error clearing presets: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============ HELPERS ============

def _dict_to_response(d: dict) -> PresetResponse:
    """Convert dict to PresetResponse"""
    return PresetResponse(
        id=d["id"],
        name=d["name"],
        description=d.get("description"),
        indicator_type=d.get("indicator_type", "dominant"),
        category=d.get("category", "mid-term"),
        symbol=d.get("symbol"),
        timeframe=d.get("timeframe"),
        params=d.get("params", {}),
        source=d.get("source", "manual"),
        is_active=d.get("is_active", True),
        is_favorite=d.get("is_favorite", False),
        tags=d.get("tags", []),
        win_rate=d.get("win_rate"),
        profit_factor=d.get("profit_factor"),
        total_profit_percent=d.get("total_profit_percent"),
        max_drawdown_percent=d.get("max_drawdown_percent"),
        sharpe_ratio=d.get("sharpe_ratio"),
        created_at=datetime.fromisoformat(d.get("created_at", datetime.utcnow().isoformat())),
        updated_at=datetime.fromisoformat(d.get("updated_at", datetime.utcnow().isoformat()))
    )


# ============ EXPORT ============

__all__ = ["router"]
